---
title: "Tema 2 — Programación en R"
lang: es
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    self-contained: true 
execute:
  echo: true
  warning: false
  message: false
editor: source
fontsize: 11pt
---


# Ciclos

Un ciclo (o bucle) permite repetir automáticamente un conjunto de instrucciones varias veces.

  * Sin bucles, tendríamos que copiar/pegar el mismo código muchas veces.

  * Con bucles, el programa se vuelve más corto, más claro y más flexible.

## Ciclo for
Sirve para repetir una instrucción un número conocido de veces (recorriendo una secuencia o vector). For es determinista, es decir, sabemos cuántas veces se repite.

Sintaxis:
```r
for (variable in secuencia) {
  # instrucciones a repetir
}

```

Ejemplos

```{r}
for (i in 1:5) {
  print(i)
}
# Imprime los números del 1 al 5
```


```{r}
nombres <- c("Ana", "Luis", "Marta")
for (n in nombres) {
  cat("Hola", n, "\n")
}

```

```{r}
for (i in c("Mi", "primer", "bucle")) {
  print("hola")
}
```

```{r}
for (i in c("Mi", "primer", "bucle")) {
  print(i)
}
```

¿Cuánto vale `i`?
```{r}
i
```

```{r}
texto <- c("Este", "es", "mi", "primerito","bucle")
palabra <- vector(length = length(texto))

for (i in 1:length(texto)) {
  palabra[i] <- texto[i]
}

palabra
```



## Ciclo while
Sirve para repetir instrucciones mientras se cumpla una condición lógica. While se utiliza cuando no sabemos cuántas iteraciones necesitaremos. Ideal para procesos que dependen de algo que no sabemos cuándo ocurrirá (ej. esperar que aparezca un valor, que el usuario adivine un número).

Sintaxis:
```r
while (condición) {
  # instrucciones a repetir
}

```
Importante: la condición debe cambiar dentro del bucle, si no, puede convertirse en un bucle infinito.


Ejemplos

```{r}
x <- 1
while (x <= 5) {
  print(x)
  x <- x + 1
}
# Hace lo mismo que el for, pero controlando la condición manualmente

```

```{r}
x <- 5
while (x > 0) {
  print(x)
  x <- x - 1
}
```

Lanzar un dado hasta obtener un 6:
```{r}
tiradas <- 0
dado <- 0
while (dado != 6) {
  dado <- sample(1:6, 1)
  tiradas <- tiradas + 1
}
cat("Se necesitaron ", tiradas, " tiradas.\n")
```


## Ejemplo con for y while. Adivinar un número.
### For
En esta versión sabemos de antemano el número máximo de intentos `n`.

```{r}
n <- 5 # número de intentos
secreto <- 7 # número secreto por adivinar
acierto <- FALSE

for (intento in 1:n) {
  propuesta <- sample(1:10, 1)   # simulamos intento
  cat("Intento", intento, ":", propuesta, "\n")
  
  if (propuesta == secreto) {
    cat("¡Has acertado!")
    acierto <- TRUE
    break   # salimos del bucle si acierta
  }
}

if (!acierto) {
  print("No acertaste en 5 intentos.")
}

```

### While
En esta versión no sabemos cuántos intentos serán necesarios, el bucle continúa hasta acertar.
```{r}
secreto <- 7
propuesta <- 15
intentos <- 0

while (propuesta != secreto) {
  propuesta <- sample(1:10, 1)   # simulamos intento
  intentos <- intentos + 1
  cat("Intento", intentos, ":", propuesta, "\n")
}

cat("¡Has acertado en", intentos, "intentos!")

```
## Bucles enlazados

¿Qué hace el siguiente código?
```{r}
n <- 3
for (i in 1:n) {
  for (j in 1:n) {
    cat("i =", i, " j =", j, "\n")
  }
}

```

¿Qué observamos?

  * El bucle externo (i) controla la fila --> cambia más lentamente.
  * El bucle interno (j) controla la columna --> cambia más rápido.
  * En total se ejecuta $n \times n$ veces (en este caso, 9 iteraciones).
  
Esto es justo lo que ocurre cuando recorremos todas las celdas de una matriz.


Podemos añadir un contador para mostrar el número de ejecución total:
```{r}
n <- 3
contador <- 0
for (i in 1:n) {
  for (j in 1:n) {
    contador <- contador + 1
    cat("Iteración", contador, ": i =", i, " j =", j, "\n")
  }
}

```

¿Cuántas veces se entra en cada bucle?
```{r}
# Dimensiones
n <- 3
m <- 4

# Contadores
cont_i <- 0
cont_j <- 0

for (i in 1:n) {
  cont_i <- cont_i + 1     # cada vez que se entra al bucle externo
  for (j in 1:m) {
    cont_j <- cont_j + 1   # cada vez que se ejecuta el bucle interno
  }
}

cat("Número de iteraciones de i:", cont_i, "\n")
cat("Número de iteraciones de j:", cont_j, "\n")

```
De forma más visual, se puede imprimir en cada vuelta los valores actuales y un contador global:
```{r}
n <- 3
m <- 4
contador <- 0

for (i in 1:n) {
  for (j in 1:m) {
    contador <- contador + 1
    cat("Iteración global:", contador, "| i =", i, "| j =", j, "\n")
  }
}

```



Algunos ejemplos:

  * Rellenar una matriz  (M[i, j] = i * j):
```{r}
n <- 5
M <- matrix(0, n, n)
for (i in 1:n) {
  for (j in 1:n) {
    M[i, j] <- i * j
  }
}
M
```


* ¿Cuántos elementos superan la media de su fila?
```{r}
set.seed(3)
M <- matrix(sample(1:9, 12, replace = TRUE), nrow = 4)
conteo_supera_media <- rep(0,nrow(M))

for (i in 1:nrow(M)) {
  media_i <- mean(M[i, ])
  cuenta <- 0
  for (j in 1:ncol(M)) {
    if (M[i, j] > media_i){
      cuenta <- cuenta + 1
    } 
  }
  conteo_supera_media[i] <- cuenta
}
conteo_supera_media

```


::: {.callout-note}
##  Ejercicios

1.  ¿Qué hace este código?

    ```{r}
for (i in seq(2, 10, 2)) {
  print(i)
}
    ```

2.  ¿Qué hace este código?
```{r}
x <- 5
while (x > 0) {
  print(x)
  x <- x - 1
}
```


3. Haz un ciclo que imprima los números del 1 al 20, pero solo los pares.

4. Haz un bucle que cuente cuántos números del 1 al 200 son múltiplos de 3.
5. Escribe un ciclo que busque el primer número mayor que 100 divisible por 13.
6. Con un ciclo, genera los 10 primeros números de la serie de Fibonacci. La serie de Fibonacci es una secuencia de números enteros en la que cada número (a partir del tercero) se obtiene sumando los dos anteriores. Los primeros términos de la serie son: 0, 1, 1, 2, 3, 5, 8, 13, ... Es decir,

  * El primer término es 0.
  * El segundo término es 1.
  * A partir del tercero: $F(n) = F(n-1) + F(n-2)$.

7. Piedra, papel o tijera. Haz un programa con un for de 5 rondas donde el ordenador elija al azar entre "piedra", "papel", "tijera", y cuente cuántas veces gana, pierde o empata contra el jugador (puede ser también aleatorio para simplificar).
8. Un estudiante mete 10 € al mes en una hucha. Usa un for para calcular cuánto dinero tendrá después de 12 meses, y luego añade un if que diga "¡Superaste los 100 €!" si corresponde.
9. Simula 10 rondas en las que se elige un número aleatorio entre 1 y 10. Si el número es par gana el Jugador A, si es impar gana el Jugador B. Al final, crea un vector que muestre cuántas rondas ganó cada jugador y quién es el ganador.
10. Crea una matriz M de tamaño $n \times m$ tal que M[i, j] = i^2 + j^2.
11. Dada una matriz M de números enteros generados aleatoriamente, construye una matriz binaria del mismo tamaño en la que:

  * El valor sea 1 si el elemento de M está por encima de la media de su columna.
  * El valor sea 0 en caso contrario (si está en la media o por debajo).
  
12. Usando el conjunto de datos iris, crea una nueva columna binaria que indique si la longitud del sépalo (Sepal.Length) de cada flor está por encima de la media de su especie.

 * Si está por encima de la media de su especie --> valor 1.
 * Si está en la media o por debajo --> valor 0.

:::

::: {.callout-tip collapse="true"}
## Soluciones

```{r}
# 1) Imprime los pares de la secuencia

# 2) Cuenta hacia atrás

# 3) 
for (i in 1:20) {
  if (i %% 2 == 0) {
    print(i)
  }
}

# 4) Contar múltiplos de 3 entre 1 y 200
contador <- 0
for (i in 1:200) {
  if (i %% 3 == 0) {
    contador <- contador + 1
  }
}
contador  # resultado

# 5) Buscar el primer número > 100 divisible por 13 (while)
n <- 101
while (n %% 13 != 0) {
  n <- n + 1
}
n  # primer múltiplo de 13 mayor que 100

# 6) Serie de Fibonacci: primeros 10 términos
fib <- numeric(10)
fib[1] <- 0; fib[2] <- 1
for (i in 3:10) {
  fib[i] <- fib[i-1] + fib[i-2]
}
fib

# 7) Piedra, papel o tijera (5 rondas aleatorias jugador vs ordenador)
opciones <- c("piedra", "papel", "tijera")
gana_j <- 0
gana_pc <- 0
empates <- 0
n_rondas <- 5
for (r in 1:n_rondas) {
  j <- sample(opciones, 1)
  pc <- sample(opciones, 1)
  if (j == pc) {
    empates <- empates + 1
  } else if ((j == "piedra"  & pc == "tijera") ||
             (j == "tijera" & pc == "papel")  ||
             (j == "papel"  & pc == "piedra")) {
    gana_j <- gana_j + 1
  } else {
    gana_pc <- gana_pc + 1
  }
}
c(gana_j = gana_j, gana_pc = gana_pc, empates = empates)

# 8) Simulación de ahorro: 10 € al mes durante 12 meses
ahorro <- 0
for (mes in 1:12) {
  ahorro <- ahorro + 10
}
ahorro
if (ahorro > 100){
  print("¡Superaste los 100 €!")
}  else {
  "No superaste los 100 €"
}

# 9) Juego de pares o impares (10 rondas)
gana_A <- 0
gana_B <- 0
n_rondas <- 10
for (r in 1:n_rondas) {
  num <- sample(1:10, 1)
  if (num %% 2 == 0) {
    gana_A <- gana_A + 1  # par --> A
  } else {
    gana_B <- gana_B + 1  # impar --> B
  }
}
c(gana_A = gana_A, gana_B = gana_B,
  ganador = ifelse(gana_A > gana_B, "A", ifelse(gana_B > gana_A, "B", "Empate")))

# 10) 
n <- 4
m <- 5
M <- matrix(0, n, m)
for (i in 1:n) {
  for (j in 1:m) {
    M[i, j] <- i^2 + j^2
  }
}
M

# 11) 
set.seed(1)
M <- matrix(sample(1:9, 20, replace = TRUE), nrow = 4)  # 4x5 matriz aleatoria
M

# Crear matriz binaria del mismo tamaño
binaria <- matrix(0, nrow = nrow(M), ncol = ncol(M))

for (j in 1:ncol(M)) {
  media_j <- mean(M[, j])
  for (i in 1:nrow(M)) {
    if (M[i, j] > media_j) {
      binaria[i, j] <- 1
    } else {
      binaria[i, j] <- 0
    }
  }
}

binaria

# 12) 
df <- iris
df$AboveMean <- 0   # inicializamos con 0

especies <- unique(df$Species)

for (s in especies) {
  # media de Sepal.Length por especie
  media_s <- mean(df$Sepal.Length[df$Species == s])
  
  for (i in 1:nrow(df)) {
    if (df$Species[i] == s & df$Sepal.Length[i] > media_s) {
      df$AboveMean[i] <- 1
    }
  }
}

head(df, 10)


```
:::




