---
title: "Tema 2 — Programación en R"
lang: es
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    self-contained: true 
execute:
  echo: true
  warning: false
  message: false
editor: source
fontsize: 11pt
---

# R

## ¿R?

**R** es un **lenguaje de programación** y un **entorno de software** diseñado específicamente para el análisis estadístico, la manipulación de datos y la visualización gráfica. Es un **software libre y de código abierto**, distribuido bajo la licencia **GNU GPL**, lo que significa que cualquiera puede usarlo, modificarlo y compartirlo sin costo.

Algunas de sus propiedades son:

-   **Multiplataforma** → Funciona en Windows, macOS y Linux.
-   **Altamente extensible** → Tiene más de **20,000 paquetes** en CRAN (repositorio oficial), además de repositorios como Bioconductor y GitHub.
-   **Especializado en estadística y ciencia de datos** → Incluye funciones nativas para análisis descriptivos, regresiones, modelos lineales y no lineales, series temporales, minería de datos, etc.
-   **Potente en visualización** → Herramientas gráficas integradas y librerías como `ggplot2`, o `plotly` permiten crear gráficos desde básicos hasta altamente interactivos.
-   **Comunidad activa** → Gran cantidad de foros, tutoriales, cursos y conferencias.

Entorno de R: <https://www.lcano.com/b/iser/_book/index.html>

**Tiene su curva de aprendizaje...¡se supera con la práctica! ;)**

**Truco**: mucho print

## Algunos ejemplos iniciales

-   Calculadora: en consola

-   Calculadora: en script. Diferencia entre .R y .qmd.

    ```{r}
    a <- 2
    b <- 3
    a*b
    ```

    ```{r}
    print('Hello world!')
    ```

```{r}
# print("Hola","casa","hogar") # error
print(c("Hola","casa","hogar")) 
```

```{r}
caracteres <- c("Hola","casa","hogar")
print(caracteres) 
```

## Variables y constantes

Una **variable** es un espacio de memoria al que se le da un nombre para almacenar un valor.

-   **Asignación:** se hace con `<-` (forma recomendada) o `=`.

-   **Dinámicas:** una variable puede cambiar de valor a lo largo de la ejecución del programa.

-   No es necesario declarar el tipo de dato (entero, float, etc.), R lo infiere automáticamente (en otros lenguajes hay que declararlo).

-   **Tipos:**

    -   Variables globales: se definen en el entorno principal (fuera de funciones) y se pueden usar en cualquier parte del script.

    -   Variables locales: se definen dentro de una función y solo existen allí. No “escapan” al entorno global.

Una **constante,** que también ocupa un espacio de memoria, es un valor fijo que no cambia durante la ejecución del programa. La diferencia entre constante y variable es que la constante es un valor predefinido, no puede cambiar (por ejemplo, $\pi$) y la variable puede cambiar su valor con la ejecución del programa.

```{r}
# Asignación de variables
x <- 10         
y <- 3          
nombre <- "Ana"  
pi_aprox <- 3.14 
```

```{r}
IVA <- 0.1
PRECIO_BASE <- 100
precio_final <- PRECIO_BASE * (1 + IVA)
precio_final

```

Dentro de una función:

```{r}
# Variables dentro de funciones no "escapan"
calcular_valor_final <- function(valor_base, impuesto) {
  valor_final <- valor_base * (1 + impuesto)
  return(valor_final)
}
```

La variable valor_final solo existe dentro de la función:

```{r}
#valor_final
# valor_final no existe fuera de la función
```

```{r}
calcular_valor_final(1000, 0.1)
```

```{r}
calcular_valor_final(5, 0.32)
```

Comentarios:

-   R distingue entre mayúsculas y minúsculas

-   R entiende igual las comillas simples (' ') y las dobles (" ").

-   A las variables y a las constantes se les debe poner un nombre identificativo.

-   Evitar todo tipo de caracteres (tildes, diéresis, ñ, etc.).

-   No pueden comenzar por caracteres ni contener espacios.

    -   Pon ejemplos válidos y no válidos de nombres de variables y constantes.

-   No se deben usar palabras reservadas de R

    ```{r}
    help(reserved)
    ```

::: {.callout-note}
##  Ejercicios

1.  Pon ejemplos válidos y no válidos de nombres de variables y constantes.

    ```{r}
    apañarse <- 7 # sí es válido pero es mejor no utilizar tildes y caracteres específicos de un idioma
    # 7a <- 6 # no podemos empezar por un número
    # $d <- 5 # no se puede empezar con dolar
    # Num piezas <- 10 # no puede haber un espacio
    NumPiezas <- 10 # Num_piezas, num.piezas

    ```

2.  Crea tres variables: tu nombre, tu edad y tu ciudad. Muéstralas en pantalla.

3.  Declara una constante `PI = 3.1416` y calcula el área de un círculo de radio 5 (área = $\pi r^{2}$).

4.  Crea dos precios y calcula el precio final con IVA = 0.21.

5.  Usa variables `base` y `altura` para calcular el área de un triángulo (área = (base $\cdot$ altura)/2).

6.  Implementa `salario_neto(bruto, tasa = 0.15)` que retorne el neto tras impuestos.
:::

::: {.callout-tip collapse="true"}
## Soluciones

```{r}
nombre <- "Ana"; edad <- 21; ciudad <- "CDMX"
nombre; edad; ciudad

PI <- 3.1416; radio <- 5; area <- PI * radio^2; area

precio1 <- 120; precio2 <- 80; IVA <- 0.21
total <- (precio1 + precio2) * (1 + IVA); total

base <- 10; altura <- 6; (base * altura) / 2

salario_neto <- function(bruto, tasa = 0.15){ bruto * (1 - tasa)}
salario_neto(1000)
```
:::

------------------------------------------------------------------------

## Tipos de datos y objetos

R cuenta con **tipos de datos** y **estructuras de datos (u objetos)**.

**Tipos de datos principales:**

-   Datos numéricos: números reales y complejos.

    -   `numeric`: números decimales (ej. `3.14`)

    -   `integer`: enteros (ej. `5L`, la L indica “integer”)

    -   `complex`: números complejos (ej. `2+3i`)

-   Caracteres: cadenas de texto representadas entre comillas.

    -   `character`: texto o cadenas de caracteres

-   Datos lógicos: únicamente pueden tomar 2 valores: TRUE, FALSE

    -   `logical`: valores lógicos (`TRUE` / `FALSE`)

```{r}
num <- 3.14
ent <- 5L # con la L le decimos que es un entero
logi <- FALSE
txt <- "Hola"
comp <- 2 + 3i

class(num); class(ent); class(logi); class(txt); class(comp)
```

**Estructuras más comunes:**

-   **vector**: Colección ordenada de datos con una longitud determinada.

-   **matrix**: estructura bidimensional (con filas y columnas) que almacena elementos del mismo tipo de dato

-   **list**: Objeto que recoge varios tipos de elementos (componentes), que pueden ser de clases diferentes.

-   **factor**: variable categórica con niveles.

-   **data.frame**: Estructuras de datos bidimensionales, donde se recogen diferentes variables por columnas. Es una estructura tabular heterogénea.

```{r}
# Vectores (todos los elementos del mismo tipo)
v_num <- c(1, 2, 3.5)
v_chr <- c("a", "b", "c")
v_log <- c(TRUE, FALSE, TRUE)

length(v_num); class(v_num)

# Si combinamos tipos de datos, R los entenderá del mismo tipo
# Por ejemplo, en el siguiente caso entiende 1 como caracter
c(1,'beta')
```

¿Cuál es la diferencia entre el objeto matrix y el objeto data.frame?

```{r}
# Matriz: 2D del mismo tipo
m <- matrix(1:6, nrow = 2, ncol = 3)   # rellena por columnas
m

# Lista: contenedor heterogéneo
lst <- list(id = 1L, nombre = "Ana", notas = c(8.5, 9, 10))
lst$nombre; lst$notas

# Data frame: tabla (cada columna puede ser de distinto tipo)
df <- data.frame(
  id = 1:3,
  nombre = c("Ana", "Luis", "Eva"),
  nota = c(9.1, 8.3, 7.5)
)
str(df); df$nombre
```

```{r}
# Factor: categorías con niveles (útil para modelos y gráficos)
sexo <- factor(c("M", "F", "F", "M"), levels = c("F", "M"))
sexo; levels(sexo)

# Coerción (cambio de tipo) y cuidado con NAs
as.numeric("10")        # 10
as.numeric(c("10", "x"))# 10 NA (warning)
as.character(1:3)       # "1" "2" "3"

```

Profundicemos en cada una de estas estructuras.

# Clase 05/09/2025

### Vectores

Mediante el siguiente código se almacena el vector (1,2,3,4) con el nombre a:

```{r}
a <- c(1,2,3,4)
```

Para mostrarlo, se debe ejecutar a:

```{r}
a
```

Podemos crear varios vectores y combinarlos:

```{r}
v1 <- c(1,2,3)
v2 <- c(7,8,9)
v3 <- c(v1,4,5,6,v2)
v3
```

Operaciones con vectores. Se aplican elemento a elemento. Se muestra el código para 2 vectores `v1` y `v2`.

**Operaciones básicas con vectores**

| Descripción    | Código      |
|----------------|-------------|
| Concatenación  | `c(v1, v2)` |
| Suma           | `v1 + v2`   |
| Resta          | `v1 - v2`   |
| Multiplicación | `v1 * v2`   |
| División       | `v1 / v2`   |
| Potencia       | `v1 ^ v2`   |

**Funciones matemáticas**

| Descripción    | Código          |
|----------------|-----------------|
| Raíz cuadrada  | `sqrt(v1)`      |
| Valor absoluto | `abs(v1)`       |
| Exponencial    | `exp(v1)`       |
| Log. base *e*  | `log(v1)`       |
| Log. base 10   | `log10(v1)`     |
| Factorial (!)  | `factorial(v1)` |

------------------------------------------------------------------------

**Estadísticos descriptivos**

| Descripción         | Código        |
|---------------------|---------------|
| Longitud            | `length(v1)`  |
| Máximo              | `max(v1)`     |
| Mínimo              | `min(v1)`     |
| Suma                | `sum(v1)`     |
| Producto            | `prod(v1)`    |
| Media               | `mean(v1)`    |
| Mediana             | `median(v1)`  |
| Desviación estándar | `sd(v1)`      |
| Varianza            | `var(v1)`     |
| Covarianza          | `cov(v1, v2)` |
| Correlación         | `cor(v1, v2)` |

¡A practicar!

1.  Almacena 2 vectores y ejecuta las funciones previas.

2.  ¿Qué significa *Inf*? ¿Y *NaN*?

Existen 3 funciones principales para crear secuencias de números en R:

-   `seq()` (sequence)

-   `rev()` (reverse)

-   `rep()` (repeat)

```{r}
v <- c(2,7,5)
# Repeticiones
rep(v, 2)
rep(v, each = 2)
rep(v, each = 2, times = 2)
rep(v, c(2, 3, 4))

# Secuencias simples
1:10
seq(1, 10)
10:1
seq(10, 1)

# Secuencias personalizadas
seq(4, length = 8)         # 8 valores desde 4
seq(0, 40, by = 5)         # de 0 a 40 en pasos de 5
seq(0, 1, length = 4)      # 4 valores equidistantes entre 0 y 1
seq(from = 2, to = 8, by = 3)

# Revertir secuencias
rev(1:5)

# Operaciones con secuencias
2 * 1:4
```

#### Operadores lógicos

Tomarán valor TRUE o FALSE.

```{r}
a <- c(-15,4,2,10,0,-2)
a > 2
a <= -10
a > 0 & abs(a) == 2
a > 0 | abs(a) == 2
```

-   ¿Cuál es la diferencia entre = y ==?

#### Indexación

La **indexación** permite acceder a los elementos de un vector. Esto significa acceder a los valores de un vector especificando su posición dentro de corchetes `[]`. Esto se realiza indicando la posición de los elementos deseados o bien mediante el uso de operadores lógicos. Se muestra el código para un vector `v`.

| Código | Descripción |
|------------------------------------|------------------------------------|
| `v[1]` | Primer elemento |
| `v[2:4]` | Del segundo al cuarto elemento |
| `v[-(2:length(v))]` | Todos menos aquellos desde el segundo hasta el último elemento |
| `v[c(2,4,6)]` | Elementos segundo, cuarto y sexto |
| `v[v > 0]` | Elementos mayores que 0 |
| `v[v != 0]` | Elementos diferentes de 0 |
| `v[abs(v) == 3]` | Elementos con valor absoluto 3 |
| `v[v > 0 & v != 2]` | Elementos positivos **y** que no sean 2 |
| `v[v < 0 | v == 3]` | Elementos negativos **o** que sean 3 |

También existe la función `which()`. En base al siguiente código, ¿cómo crees que funciona?

```{r}
v <- c(0,3,0,1,3,0)
which(v==0)
which(v>0 & v<=2)
```

¿Y las funciones `which.min()` y `which.max()`?

::: {.callout-note}
##  Ejercicios

Dado el vector

```{r}
v <- -5:5
```

Indique qué se obtiene con las siguientes expresiones:

1.  `v[c(1, length(v))]`
2.  `v[3:7]`
3.  `v[-c(1, length(v))]`
4.  `v[v >= 0]`
5.  `v[abs(v) == 4]`
6.  `v[v != -3 & v != 3]`
7.  `v[v < -2 | v > 2]`
:::

::: {.callout-tip collapse="true"}
## Soluciones

```{r}
# Suponiendo un vector v definido, por ejemplo:
v <- -5:5

# 1) v[c(1, length(v))]
# Devuelve el primer y el último elemento del vector.
v[c(1, length(v))]

# 2) v[3:7]
# Devuelve los elementos desde la posición 3 hasta la 7.
v[3:7]

# 3) v[-c(1, length(v))]
# Devuelve todos los elementos excepto el primero y el último.
v[-c(1, length(v))]

# 4) v[v >= 0]
# Devuelve los elementos que son mayores o iguales a cero.
v[v >= 0]

# 5) v[abs(v) == 4]
# Devuelve los elementos cuyo valor absoluto es exactamente 4.
v[abs(v) == 4]

# 6) v[v != -3 & v != 3]
# Devuelve todos los elementos excepto los iguales a -3 o a 3.
v[v != -3 & v != 3]

# 7) v[v < -2 | v > 2]
# Devuelve los elementos que son menores que -2 o mayores que 2.
v[v < -2 | v > 2]
```
::: 

::: {.callout-note}
##  Ejercicios
Dado un vector `v`, escribe la instrucción en R que permita obtener lo siguiente:

8. El segundo elemento del vector.
9. Todos los elementos en posiciones pares.
10. Los tres primeros elementos.
11. Los elementos que sean negativos.
12. Los elementos que sean múltiplos de 5. a%%b==0 entonces a es múltiplo de b
13. El vector sin el tercer elemento.
14. El mayor valor del vector (usando indexación, no solo max(v)).
15. Los elementos que estén entre -2 y 2 inclusive.
:::

::: {.callout-tip collapse="true"}
## Soluciones

```{r}
# 8) Segundo elemento
v[2]

# 9) Posiciones pares
v[seq(2, length(v), by = 2)]

# 10) Tres primeros
v[1:3]

# 11) Negativos
v[v < 0]

# 12) Múltiplos de 5
v[v %% 5 == 0]

# 13) Sin el tercer elemento
v[-3]

# 14) Mayor valor (vía indexación)
max(v) ; v[which.max(v)] # ¿Qué solución es mejor?

# 15) Entre -2 y 2 inclusive
v[v >= -2 & v <= 2]
```
::: 

### Matrices

Una matriz $M$ de tamaño $n \times s$ es:

$M =\left( \begin{matrix} m_{11} & m_{12} & m_{13} & \cdots & m_{1s} \\ m_{21} & m_{22} & m_{23} & \cdots & m_{2s} \\ m_{31} & m_{32} & m_{33} & \cdots & m_{3s} \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ m_{n1} & m_{n2} & m_{n3} & \cdots & m_{ns} \end{matrix}\right)$

Creamos una matriz a partir de un vector:

```{r}
v <- 1:8
dim(v)<-c(4,2)
v
```

Nótese que, por defecto, R coloca los valores de arriba a abajo. Esto, por supuesto, es modificable.

```{r}
v <- 1:7
#dim(v)<-c(4,2)
#v
```

```{r}
matrix(1:8,nrow=2,ncol=4)
```

```{r}
matrix(1:3,3,3)
```

```{r}
matrix(1:3,3,3, byrow = TRUE)
```

Especificamos número de filas o de columnas:

```{r}
matrix(1:6,nrow=2)
matrix(1:4,ncol=2)
```

La función rbind() une por filas y cbind() une por columnas.

```{r}
a<-matrix(0,2,2)
b<-matrix(1,1,2)
rbind(a,b)
cbind(1,1:4)
```

#### Array

Estructura que organiza los datos en $k$ dimensiones.

```{r}
array(1:4,c(2,2,2))
```

#### Indexación y submatrices

Al igual que accedíamos a elementos de los vectores con los \[\], podemos acceder a elementos de las matrices. Esto permite no sólo acceder a elementos, también modificarlos y obtener submatrices.

```{r}
a <- matrix(1:9*3,3,3)
a[1,2] # Elemento de la fila 1 y la columna 2
a[,3] # Tercera columna
a[2,] # Segunda fila
a[-1, -3] # Todas las filas menos la primera y todas las columnas menos la tercera
a[2:3,1] # De la fila 2 a la 3, columna 1
```

```{r}
# Cambiar elementos
a[,1]<-0
```

Algunas operaciones básicas con matrices son:

-   Dimensión de la matriz: `dim()`

-   Transpuesta: `t()`

-   Número de filas: `nrow()`

-   Número de columnas: `ncol()`

-   Suma de filas: `rowSums()`

-   Suma de columnas: `colSums()`

-   Media de las filas: `rowMeans()`

-   Media de las columnas: `colMeans()`

Investiga las funciones `is.vector()`, `is.matrix()`, `as.vector()`, `as.matrix()`. ¿Qué hacen?

::: {.callout-note}
##  Ejercicios

1.   Crea una matriz llamada `M` de tamaño 3x3 con números de -2 a 6.
2.   Sustituye el valor de la fila 2, columna 3 por 100.
3.   Muestra todos los valores de la fila 1.
4.   Muestra todos los valores de la columna 2.
5.   Selecciona las dos primeras filas y las dos primeras columnas.
6.   Añade una nueva fila con valores `c(10,20,30)`.
7.   Añade una columna con valores `c(5,5,5,5,5)`.
8.   Añade una columna con valores `c(5,-5,5,-5)`.
9.   Cambia a 0 todos los elementos mayores que 20.
10.   Cambia los valores negativos menores de -1 por su valor absoluto.
11. Obtén la suma de las filas.
12. Obtén la media de las columnas.
13. ¿Cuál es la dimensión final de la matriz?
14. Pon nombres a las filas y a las columnas.
:::

::: {.callout-tip collapse="true"}
## Soluciones

```{r}
## 1) Matriz M 3x3 con números de -2 a 6
M <- matrix(-2:6, nrow = 3, ncol = 3)
M

## 2) Sustituye fila 2, columna 3 por 100
M[2, 3] <- 100
M

## 3) Todos los valores de la fila 1
M[1, ]

## 4) Todos los valores de la columna 2
M[, 2]

## 5) Dos primeras filas y dos primeras columnas
M[1:2, 1:2]

## 6) Añade una nueva fila c(10,20,30)
M <- rbind(M, c(10, 20, 30))
M  # ahora 4 x 3

## 7) Añade una columna c(5,5,5,5,5)
##    No cumple con las dimensiones de la matriz: cbind(M, c(5,5,5,5,5))

## 8) Añade una columna c(5,-5,5,-5)
M <- cbind(M, c(5, -5, 5, -5))
M  # ahora 4 x 5

## 9) Cambia a 0 todos los elementos > 20
M[M > 20] <- 0
M

## 10) Cambia a su valor absoluto los negativos menores de -1
idx <- M < -1
M[idx] <- abs(M[idx])
M

## 11) Suma de las filas
rowSums(M)

## 12) Media de las columnas
colMeans(M)

## 13) Dimensión final de la matriz
dim(M)

## 14) Pon nombres a las filas y a las columnas
rownames(M) <- paste0("Fila", 1:nrow(M))
colnames(M) <- paste0("Col", 1:ncol(M))
M
#Otra opción es:
rownames(M) <- c("row1","row2","row3","row4")
```
::: 

### Factor

Un factor es un tipo especial de vector para representar variables de tipo atributo o categóricas. En general, la característica podrá tomar un reducido número de valores diferentes, identificados con etiquetas (*labels*) y que llamaremos **niveles** del factor (*levels*). R crea los niveles del factor a partir de los distintos valores que toma la variable (valores únicos, que se pueden obtener con la función `unique`) ordenados de forma ascendente, y almacena solamente el código de etiqueta.

```{r}
factor(c("viejo", "viejo", "nuevo1", "nuevo2"), 
       levels = c("viejo", "nuevo1", "nuevo2"))
```

Imaginemos que tenemos las siguientes piezas:

```{r}
piezas <- c(1, 2, 3, 3)
piezas
```

```{r}
piezas <- factor(piezas,labels = c("M01", "M02", "M03"))
piezas
```

::: {.callout-note}
##  Ejercicios

1.  Crea un vector con las categorías `"Alto"`, `"Medio"`, `"Bajo"`, repitiéndolas varias veces, y conviértelo en un factor.
2.  Verifica los niveles del factor.
3.  Consulta cuántos elementos hay de cada nivel usando `table()`.
4.  Crea un factor ordenado llamado `talla` con los valores `c("S", "M", "L", "S", "L", "M")`, donde el orden sea `S < M < L`.
5.  Comprueba qué talla es mayor: `"S"` o `"M"`.
6.  Dado un vector de calificaciones `c(4, 7, 9, 5, 8, 3)`, crea un factor categorizando cada nota en:

    -   `"Suspenso"` (\<5)

    -   `"Aprobado"` (5–6.9)

    -   `"Notable"` (7–8.9)

    -   `"Sobresaliente"` (≥9)
  Usa la función `cut()`.
:::

::: {.callout-tip collapse="true"}
## Soluciones

```{r}
## 1) 
niveles <- c("Alto", "Medio", "Bajo", "Alto", "Bajo")
f <- factor(niveles)
f

## 2) 
levels(f)

## 3) 
table(f)

## 4) 
talla <- factor(c("S", "M", "L", "S", "L", "M"),
                    levels = c("S", "M", "L"),
                    ordered = TRUE)
talla
    
## 5) 
talla[1] < talla[2]   # TRUE

## 6) 
notas <- c(4, 7, 9, 5, 8, 3)
categorias <- cut(notas,
                      breaks = c(-Inf, 5, 7, 9, Inf),
                      labels = c("Suspenso", "Aprobado", "Notable", "Sobresaliente"),
                      right = FALSE)
categorias
table(categorias)
class(categorias)
```
::: 


### Listas

Las listas son estructuras de datos que contienen una colección de elementos indexados, que pueden además tener un nombre. Pueden ser heterogéneas en el sentido de que cada elemento de la lista puede ser de cualquier tipo.

Las listas se pueden anidar, de forma que un elemento de la lista puede ser, a su vez, una lista. Accederemos a estos elementos profundizando con el mismo operador `$`, por ejemplo `lista1$elemento1$subelemento2`.

```{r}
# Lista: contenedor heterogéneo
lst <- list(fruta = "manzana", peso = c(125, 115, 209))
lst; lst$fruta; lst$peso
```

```{r}
lst["fruta"]; lst['peso'] 
```

```{r}
lst[1]; lst[[1]]
```

::: {.callout-note}
##  Ejercicios

1.  Crear una lista llamada `persona` con los siguientes elementos:

    -   nombre: `"Carmen"`

    -   edad: `21`

    -   notas: `c(8.5, 9, 7.5)`

2.  Accede al nombre de la persona usando `$` y usando `[[]]`
3.  A partir de la lista `persona`, accede a la segunda nota.
4.  Cambia la edad de `persona` a `24`.
5.  Agrega un nuevo elemento llamado `deporte` con valor `"Atletismo"`.
6.  Crea una lista `clase` con tres alumnos, cada uno con sus propios datos (nombre, edad y notas).
7.  Accede al nombre del segundo alumno.
8.  Resta un punto a la primera nota del alumno 3.
:::

::: {.callout-tip collapse="true"}
## Soluciones

```{r}
## 1) 
persona <- list(
    nombre = "Carmen",
    edad = 21,
    notas = c(8.5, 9, 7.5)
    )

## 2) 
persona$nombre
persona[["nombre"]]
    
## 3) 
persona$notas[2]

## 4) 
persona$edad <- 24

## 5) 
persona$deporte <- "Atletismo"

## 6) 
clase <- list(
      alumno1 = list(nombre = "Ana", edad = 21, notas = c(9, 8, 7)),
      alumno2 = list(nombre = "Luis", edad = 22, notas = c(6, 7, 8)),
      alumno3 = list(nombre = "Carlos", edad = 23, notas = c(10, 9, 9.5))
    )

## 7) 
clase$alumno2$nombre

## 8)
clase$alumno3$notas[1] <- clase$alumno3$notas[1] - 1

```
:::

### DataFrames
Un data frame en R es una estructura de datos bidimensional en forma de tabla, similar a una hoja de cálculo o a una tabla de base de datos. Cada columna es un vector, y puede tener un tipo de dato distinto (números, texto, lógicos, factores, etc.). Todas las filas representan observaciones (registros) y tienen la misma longitud.
Es la estructura más utilizada en R para análisis de datos (existen versiones más modernas como `tibble` del paquete `tibble` y `dplyr`), ya que permite organizar datos de manera clara y trabajar con ellos mediante funciones estadísticas y gráficas. Algunas características son:

- Bidimensional: filas y columnas.
- Heterogéneo por columnas: cada columna puede tener un tipo de dato diferente.
- Homogéneo por columna: dentro de una columna, todos los datos son del mismo tipo.
- Indexación: se puede acceder a elementos por [fila, columna], por nombre de columna ($) o por índices.

Un ejemplo básico de creación de un dataframe sería:
```{r}
df <- data.frame(
  id = 1:3,
  nombre = c("Ana", "Luis", "Eva"),
  edad = c(21, 25, 23),
  aprobado = c(TRUE, TRUE, FALSE)
)

df
```

Podemos acceder a los datos de forma similar a como hemos visto para otras estructuras de datos:
```{r}
df$nombre        # Columna 'nombre'
df[ , "edad"]    # Columna 'edad'
df[1, ]          # Primera fila completa
df[2, 3]         # Elemento fila 2, columna 3 (edad de Luis)
```

Algunas funciones comunes son:

- `nrow(df)`:  Número de filas
- `ncol(df)`: Número de columnas
- `colnames(df)`:  Nombres de columnas
- `rownames(df)`: Nombres de filas
- `str(df)`: Estructura
- `summary(df)`: Resumen estadístico
- `head(df)`: primeras filas del dataframe

Podemos cargar algunos dataframes ya contenidos en paquetes de R. Por ejemplo, el conjunto de datos iris cuenta con mediciones de pétalos y sépalos de tres especies de flores.
```{r}
head(iris)
```
```{r}
iris
```


```{r}
str(iris)
```


```{r}
summary(iris)
```


::: {.callout-note}
##  Ejercicios

1. Crea un data frame llamado `df` con tres columnas:
  - `id` con valores del 1 al 3,
  - `nombre` con tres nombres,
  - `edad` con tres edades.
2. Muestra el número de filas y de columnas del data frame.
3. Consulta los nombres de las columnas y de las filas.
4. Accede a la segunda fila completa del data frame.
5. Extrae la columna `edad` de tres maneras distintas:
  - usando $,
  - usando corchetes con nombre de columna,
  - usando el índice de la columna.
6. Cambia el nombre de la segunda fila a `"AlumnoB"`.
7. Renombra la columna nombre a `NombreCompleto`.
8. Añade una nueva columna `curso` con los valores `"R1"`, `"R2"`, `"R3"`.
9. Añade una nueva fila con los datos: `id=4`, `NombreCompleto="Eva"`, `edad=22`, `curso="R1"`.
10. Convierte la columna `curso` en un factor y muestra sus niveles.
11. Convierte el data frame en una matriz con `as.matrix()` y explica la diferencia observada en los tipos de datos.
:::

::: {.callout-tip collapse="true"}
## Soluciones

```{r}
# 1) Crear df
df <- data.frame(
  id     = 1:3,
  nombre = c("Ana", "Luis", "Mario"),
  edad   = c(20, 22, 21)
)
df

# 2) Número de filas y columnas
nrow(df)
ncol(df)

    
# 3) Nombres de columnas y filas 
colnames(df)
rownames(df)

# 4) Segunda fila completa
df[2, ]


# 5) Columna 'edad' de tres formas
df$edad
df[, "edad"]
df[[3]]         # tercera columna


# 6) Cambiar nombre de la segunda fila a "AlumnoB"
rownames(df)[2] <- "AlumnoB"
rownames(df)


# 7) Renombrar columna 'nombre' a 'NombreCompleto'
names(df)[names(df) == "nombre"] <- "NombreCompleto"
colnames(df) 


# 8) Añadir columna 'curso'
df$curso <- c("R1", "R2", "R3")
df


# 9) Añadir una nueva fila
df <- rbind( df, data.frame(id = 4, NombreCompleto = "Eva", edad = 22, curso = "R1"))
row.names(df) <- NULL # resetear el nombre de las filas

# 10) Convertir 'curso' en factor y mostrar niveles
class(df$curso)
df$curso <- factor(df$curso)
levels(df$curso)
class(df$curso)

# 11) Convertir el data frame en matriz
M <- as.matrix(df)
str(M)   # todos los elementos del mismo tipo, character


```
:::

Practiquemos un poco más con el dataframe penguins de la librería palmerpenguins de R. Para ello, debemos comenzar por instalar y cargar la librería.
```{r}
install.packages("palmerpenguins") # solo se ejecuta 1 vez
library(palmerpenguins)
penguins
```
::: {.callout-note}
##  Ejercicios
1. Vistazo general
  - Muestra las primeras filas de penguins.
  - Ejecuta summary(penguins) y comenta qué información devuelve.

2. Filtro simple: ¿Cuántos pingüinos son hembra (sex == "female") y cuántos son macho (sex == "male")? 

3. Filtro con condiciones: Obtén el peso corporal (body_mass_g) de los pingüinos de la isla "Dream" que sean machos.

4. Acceso a columnas
  - Extrae la columna species como vector.
  - Extrae simultáneamente las columnas species y island.

5. ¿Cuál es el número de especies distintas en el dataset?
:::

::: {.callout-tip collapse="true"}
## Soluciones

```{r}
library(palmerpenguins)

# 1) Inspección
head(penguins)
summary(penguins)

# 2) Conteo por sexo
table(penguins$sex)

# 3) Peso de machos en la isla Dream
penguins$body_mass_g[penguins$island == "Dream" & penguins$sex == "male"]

# 4) Acceso a columnas
penguins$species
penguins[, c("species", "island")]

# 5) Número de especies distintas
length(unique(penguins$species))
```
::: 