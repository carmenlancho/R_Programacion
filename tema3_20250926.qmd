---
title: "Tema 3 — Manejo de bases de datos (R)"
lang: es
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    self-contained: true 
execute:
  echo: true
  warning: false
  message: false
editor: source
fontsize: 11pt
---


# ¿Qué veremos en cada subtema?

  * 3.0 Lectura de datos: cómo importar datos desde csv, excel, etc., inspeccionarlos rápidamente y fijar opciones (encoding, separadores, valores perdidos), revisar cabeceras y fechas.

  * 3.1 Limpieza: detección y tratamiento de datos faltantes, duplicados, outliers; corrección de tipos (numérico, fecha, factor), normalización de texto (acentos, mayúsculas/minúsculas).

  * 3.2 Codificación: creación y recodificación de variables (dummies/factores), estandarización o discretización cuando corresponda, construcción de índices simples.

  * 3.3 Análisis: estadísticas descriptivas, tablas y relaciones entre variables.

  * 3.4 Selección: filtrado por condiciones, columnas, subpoblaciones; muestreo simple.

  * 3.5 Visualización: gráficos básicos para monitoreo (tendencias, comparaciones entre grupos).

  * 3.6 Ejemplos con librerías en R: flujos reproducibles con dplyr, readr/readxl, lubridate, ggplot2, etc.
  
**Lectura de datos**

*Objetivo:* Saber importar datos correctamente y verificar que R ha interpretado bien tipos, encabezados y valores perdidos.

El formato importa:

  * separador (, ; \t), 
  * encoding (UTF-8), 
  * NA (valores especiales), 
  * fechas (YYYY-MM-DD).

Verificación rápida: tamaño, tipos de columnas, primeros registros, resumen.

Ejemplos

```{r}
# CSV (separador coma, codificación UTF-8)
library(readr)
encuesta <- read_csv("datos/encuesta_beneficiarios.csv", locale = locale(encoding = "UTF-8"))

# Excel
library(readxl)
padron <- read_excel("datos/padron_municipal.xlsx", sheet = "2024")

# JSON (por ejemplo, catálogo)
library(jsonlite)
cat_programas <- fromJSON("datos/catalogo_programas.json")

```






# Limpieza

Cuando nos enfrentamos a un conjunto de datos es importante revisar los datos para eliminar posibles errores o insconsistencias:

  * Faltantes (NA): ¿faltó respuesta? ¿códigos especiales? Decidir: imputar, eliminar, o dejar según análisis.

  * Duplicados: filas repetidas (registro, id).

  * Tipos incorrectos: números leídos como texto; fechas mal parseadas --> resultados erróneos.

  * Outliers: valores extremos (errores de captura o casos reales). Documentar criterios.

  * Normalizar texto: acentos, espacios, mayúsculas/minúsculas, para unir/contar bien.


**Caso de trabajo**

Supongamos los siguientes datos provenientes de una encuesta:
```{r}
encuesta <- data.frame(
  id = 1:12,
  sexo = c("M", "F", "F", NA, "F", "M", "M", "F", "F", "Otro", "M", "F"),
  edad = c(22, 35, NA, 29, 44, 19, 200, 61, 28, 37, 40, NA),   # 200 = outlier
  ingreso_mensual = c(4500, 8000, NA, 5200, 300000, 0, 6200, 7000, 5900, NA, 4800, 5100), # 300000 outlier
  municipio = c("León", "León", "Irapuato", "Celaya", "León", "Celaya",
                "Irapuato", "Celaya", "León", "León", "Irapuato", "Celaya"),
  fecha = c("2024-03-01","2024/03/05","2024-03-05","03-10-2024","2024-03-12",
            "2024-03-12", "2024-15-12", NA, "2024-03-20","2024-03-22","2024-03-25","2024-03-25")
)

```


**Datasets (incluidos en R)**

  * USArrests: 50 estados y 4 variables de criminalidad (útil para ejemplos de NA/outliers si introducimos NA artificialmente y para escalado).

  * airquality: tiene NA reales

  * swiss: numérico/factores; socioeconómico clásico.
  

## Faltantes (NA) y duplicados

```{r}
# Conteo de NA por columna
colSums(is.na(encuesta))

# Eliminar filas completamente vacías (si existieran)
encuesta <- encuesta[rowSums(is.na(encuesta)) < ncol(encuesta), ]

# Duplicados por id
sum(duplicated(encuesta$id))
encuesta <- encuesta[!duplicated(encuesta$id), ]

```

## Tipos y fechas

```{r}
library(lubridate)

# Varios formatos comunes en los datos:
# - "2024-03-01"  -> "%Y-%m-%d"
# - "2024/03/05"  -> "%Y/%m/%d"
# - "03-10-2024"  -> "%d-%m-%Y"
# - "2024-15-12"  -> "%Y-%d-%m"  (día-mes intercambiado en cadenas tipo "Y-d-m")

# Armonizar formato de fecha
encuesta$fecha_ok <- encuesta$fecha_ok <- parse_date_time(encuesta$fecha,orders=c('ymd','y/m/d','dmy','mdy','ydm'))

# Comprobar cuántas no se pudieron parsear:
sum(is.na(encuesta$fecha_ok))
which(is.na(encuesta$fecha_ok))


# Corregir valores imposibles a NA o revisarlos manualmente
encuesta$edad <- ifelse(encuesta$edad < 0 | encuesta$edad > 110, NA, encuesta$edad)

```


## Outliers simples (reglas heurísticas)

En evaluación real es necesario justificar umbrales

```{r}
# Por ingreso: marcar outliers por percentiles (p99)
p99 <- quantile(encuesta$ingreso_mensual, 0.99, na.rm = TRUE)
encuesta$ingreso_mensual <- ifelse(encuesta$ingreso_mensual > p99, 'NA', encuesta$ingreso_mensual) # NA no, nombrar

```


## Normalización de texto

```{r}
# Quitar espacios, pasar a minúsculas, quitar acentos con iconv
encuesta$mun_norm <- tolower(trimws(encuesta$municipio))
encuesta$mun_norm <- iconv(encuesta$mun_norm, from = "", to = "ASCII//TRANSLIT") # "leon" "leon" "leon" "irapuato" "celaya"

```
¿Qué hace cada función?

## Imputación

```{r}
# Imputar ingreso_mensual
encuesta$ingreso_mensual <- as.numeric(encuesta$ingreso_mensual)
value_imputed <- data.frame(

                original = encuesta$ingreso_mensual,
                imputed_zero = replace(encuesta$ingreso_mensual, is.na(encuesta$ingreso_mensual), 0),
                imputed_mean = replace(encuesta$ingreso_mensual, is.na(encuesta$ingreso_mensual), mean(encuesta$ingreso_mensual, na.rm = TRUE)))

```


NAs: 
```{r}
data("airquality")     # ozono, radiación solar, etc. en NY 1973
aq <- airquality

# 1) Faltantes
colSums(is.na(aq))         # NA por columna
which(is.na(aq$Ozone))     # posiciones con NA en Ozone

# 2) Eliminar filas con demasiados NA (ejemplo: si todas las numéricas están NA)
aq2 <- aq[rowSums(is.na(aq)) < ncol(aq), ]

# 3) Rellenar NA con mediana de la columna (simple; documentar!)
med_oz <- median(aq$Ozone, na.rm = TRUE)
aq$Ozone_imp <- ifelse(is.na(aq$Ozone), med_oz, aq$Ozone)


```


Duplicados:
```{r}
df <- data.frame(id = c(1,2,2,3), x = c(10, 20, 20, 30))
duplicated(df$id)       # TRUE en la segunda aparición
df_nodup <- df[!duplicated(df$id), ]

```


::: {.callout-note}
##  Ejercicios
1.  Lee el conjunto de datos encuesta_beneficiarios_v2.
2.  Cuenta NA por columna y por municipio, ¿qué variable tiene más faltantes?
3.  Armoniza `fecha` y escribe cuántos registros quedaron sin fecha válida.

4. Marca outliers de `edad` con regla edad > 100 y pásalos a NA.

5. Estandariza `municipio` a minúsculas sin acentos, crea municipio_norm.
6. Imputa `ingreso_mensual` por mediana dentro de municipio_norm y compara la distribución antes/después.
7. Crea un `data.frame` con duplicados en id y elimina los registros repetidos conservando la primera aparición.

8. Con `airquality`, cuenta NA por columna y reemplaza NA en `Solar.R` por la media.
9. En `airquality`, 'cap' (recorta) `Ozone` al percentil 99 y compara `summary()` antes/después.


:::

::: {.callout-tip collapse="true"}
## Soluciones

```{r}

# 1) Leer conjunto de datos
encuesta_v2 <- read.csv("datos/encuesta_beneficiarios_v2.csv",
                        fileEncoding = "UTF-8",
                        na.strings = c("", "NA"),
                        stringsAsFactors = FALSE)
head(encuesta_v2)

# 2) 
## NA por columna
na_por_col <- colSums(is.na(encuesta_v2))
na_por_col
var_mas_NA <- names(which.max(na_por_col))
cat("Variable con más NA:", var_mas_NA, "(", max(na_por_col), "NA )\n")

## NA por municipio (cuenta de filas con al menos 1 NA)
na_por_mpio <- tapply(rowSums(is.na(encuesta_v2)) > 0, encuesta_v2$municipio, sum)
na_por_mpio

# 3) 
## Intentar varios formatos comunes:
## - "YYYY-MM-DD"   (2024-03-01)
## - "YYYY/MM/DD"   (2024/03/05)
## - "DD-MM-YYYY"   (03-10-2024)  -> as.Date con formato "%d-%m-%Y"
f1 <- as.Date(encuesta_v2$fecha, format = "%Y-%m-%d")
f2 <- as.Date(encuesta_v2$fecha, format = "%Y/%m/%d")
f3 <- as.Date(encuesta_v2$fecha, format = "%d-%m-%Y")

## Tomar la primera que funcione por fila
fecha_ok <- ifelse(!is.na(f1), f1,
                   ifelse(!is.na(f2), f2,
                          ifelse(!is.na(f3), f3, NA)))
encuesta_v2$fecha_ok <- as.Date(fecha_ok, origin = "1970-01-01")

## Cuántas quedaron sin fecha válida
sum(is.na(encuesta_v2$fecha_ok))
which(is.na(encuesta_v2$fecha_ok))


# 4)
encuesta_v2$edad_out_na <- ifelse(!is.na(encuesta_v2$edad) & encuesta_v2$edad > 100, NA, encuesta_v2$edad)
table(is.na(encuesta_v2$edad), is.na(encuesta_v2$edad_out_na))

# 5) 
encuesta_v2$municipio_norm <- trimws(encuesta_v2$municipio)
encuesta_v2$municipio_norm <- tolower(encuesta_v2$municipio_norm)
encuesta_v2$municipio_norm <- iconv(encuesta_v2$municipio_norm, from = "", to = "ASCII//TRANSLIT")
encuesta_v2$municipio_norm

# 6)
## Vector de medianas por municipio_norm (ignora NA)
medianas_por_mun <- tapply(encuesta_v2$ingreso_mensual,
                           encuesta_v2$municipio_norm,
                           median, na.rm = TRUE)

## Variable imputada
encuesta_v2$ingreso_imp <- ifelse(
  is.na(encuesta_v2$ingreso_mensual),
  medianas_por_mun[as.character(encuesta_v2$municipio_norm)],
  encuesta_v2$ingreso_mensual
)

## Comparar distribuciones
summary(encuesta_v2$ingreso_mensual)
summary(encuesta_v2$ingreso_imp)


# 6) 

duplicated(encuesta_v2)        # marca duplicados (TRUE a partir de la 2ª aparición)
encuesta_v2_nodup <- encuesta_v2[!duplicated(encuesta_v2), ]  # conserva la primera aparición de cada obervacióm
encuesta_v2_nodup


# 7)
data("airquality")
aq <- airquality

colSums(is.na(aq))  # NA por columna

mean_solar <- mean(aq$Solar.R, na.rm = TRUE)
aq$Solar.R_imp <- ifelse(is.na(aq$Solar.R), mean_solar, aq$Solar.R)

## Verificación
cbind(Original = colSums(is.na(airquality)),
      ConImput = colSums(is.na(aq)))
summary(aq$Solar.R)
summary(aq$Solar.R_imp)

# 8)
## Crear versión imputada simple para no perder casos
oz_imp <- ifelse(is.na(aq$Ozone), median(aq$Ozone, na.rm = TRUE), aq$Ozone)

summary(aq$Ozone)   # original con NA
summary(oz_imp)     # imputada por mediana




```
:::


# Codificación

Transformamos variables para análisis: recodificar categorías, crear dummies, agrupar rangos, estandarizar o construir índices sencillos:

  * Recodificación: mapear categorías sueltas a valores coherentes (p. ej., "M/m/Masculino" --> "Masculino").

  * Factores: variables categóricas con niveles ordenados (útil para modelos/tablas).

  * Dummies: 0/1 para usar categorías en modelos/regresiones.

  * Binning: pasar continuo a rangos (cuartiles, umbrales específicos).

  * Estandarizar: poner variables en escalas comparables (media 0, sd 1) para construir índices.


## Recodificación y factores

Recodificar texto a categorías limpias:

```{r}
sexo_raw <- c("M", "F", "female", "Masculino", "Otro", NA, "m", "Femenino")
sexo_rec <- ifelse(sexo_raw %in% c("F","Femenino","female","f"), "Femenino",
                   ifelse(sexo_raw %in% c("M","Masculino","male","m"), "Masculino",
                          "Otro"))
sexo_fac <- factor(sexo_rec, levels = c("Femenino","Masculino","Otro"))
table(sexo_fac, useNA = "ifany")

```





## Dummies (variables indicadoras)

```{r}
mujer <- as.integer(sexo_fac == "Femenino")   # 1 si Femenino, 0 si no
# También lo podríamos hacer con ifelse

```


## Binning / categorías por rangos

```{r}
edad <- c(19, 25, 44, 65, 70, NA)
tramo_edad <- cut(edad,
                  breaks = c(-Inf, 29, 64, Inf),
                  labels = c("Joven","Adulto","Mayor"),
                  right = TRUE)
tramo_edad

```



## Estandarización
```{r}
# Estandarizar ingreso_imp (media 0, sd 1)
encuesta$ingreso_z <- scale(encuesta$ingreso_mensual)[,1]
# z-score
```

## Índice simple (combinando componentes)
Solo a modo ilustrativo, en proyectos reales es necesario justificar todas las decisiones.

```{r}
# Ejemplo: mayor ingreso (z) y menor edad (normalizada inversa)
# normalizar edad a [0,1] ignorando NA
rng <- range(encuesta$edad, na.rm = TRUE)
edad_norm <- (max(encuesta$edad, na.rm = TRUE) - encuesta$edad) / diff(rng)   # mayor valor = más joven
indice <- 0.7 * encuesta$ingreso_z + 0.3 * edad_norm
indice
# Un índice simple: ingreso_z y (edad invertida)
```

**Ejemplos**
Con `USArrests` (criminalidad por estado)
```{r}
data("USArrests")
ua <- USArrests
# Crear categorías de "UrbanPop" (por terciles) y dummies (base)
cortes_u <- quantile(ua$UrbanPop, c(0, 1/3, 2/3, 1), na.rm = TRUE)
ua$UrbanCat <- cut(ua$UrbanPop, breaks = cortes_u, include.lowest = TRUE,
                   labels = c("Baja","Media","Alta"))
ua$UrbanAlta <- as.integer(ua$UrbanCat == "Alta")

# Estandarizar tasas para un índice de 'riesgo' simple
ua$Assault_z <- as.numeric(scale(ua$Assault))
ua$Murder_z  <- as.numeric(scale(ua$Murder))
ua$Rape_z    <- as.numeric(scale(ua$Rape))
ua$Riesgo    <- 0.5 * ua$Assault_z + 0.3 * ua$Murder_z + 0.2 * ua$Rape_z
head(ua)

```




::: {.callout-note}
##  Ejercicios

Con el conjunto de datos swiss, que se carga del siguiente modo:
```{r}
data("swiss")
sw <- swiss
```
Realiza los siguientes ejercicios. No olvides que el primer paso siempre es echarle un vistazo a los datos.

1. Clasificación de Fertilidad: Clasifica la variable Fertility en cuartiles ("Q1"..."Q4") y crea una variable FertAlta que valga 1 si el distrito está en el cuartil superior y 0 en caso contrario.

2. Índice Educativo–Examen: Estandariza Education y Examination (z-score) y crea un índice combinado $IdxEduEx = 0.5*Education_z + 0.5*Examination_z$. Examina su distribución.

3. Catolicidad en 3 grupos: Agrupa la variable Catholic en tres rangos ("Baja", "Media", "Alta") y crea una variable MayorCat que valga 1 si está en el grupo "Alta" y 0 en otro caso.

4. Índice de Desventaja Infantil: Normaliza Infant.Mortality y Fertility en [0,1] (comienza creando una función que realice dicha normalización) y define $IdxDesvInf = 0.6*InfantMM + 0.4*FertMM$. Interpreta su summary().

5. Rank y Top 5 Distritos: Calcula el ranking (1 = más alto) de `IdxDesvInf` y lista los 5 distritos con valores más altos. (Pista: `order()`).

6. Cruce de variables: Cruza los cuartiles de Fertility con los 3 niveles de Catholic (CatCat) y muestra la tabla de contingencia.

7. Alta Educación y Fertilidad: Crea EduAlta = 1 si Education está en el cuartil superior y compara la media de Fertility entre EduAlta=1 y EduAlta=0.

:::

::: {.callout-tip collapse="true"}
## Soluciones

```{r}

# Carga de datos
data("swiss")
sw <- swiss
head(sw)
str(sw)         # 47 distritos x 6 variables numéricas
# Variables: Fertility, Agriculture, Examination, Education, Catholic, Infant.Mortality

# 1) 
cortes_f <- quantile(sw$Fertility, probs = c(0,0.25,0.5,0.75,1), na.rm = TRUE)
sw$Fert_quart <- cut(sw$Fertility, breaks = cortes_f, include.lowest = TRUE,
                     labels = c("Q1","Q2","Q3","Q4"), ordered_result = TRUE)
sw$FertAlta <- as.integer(sw$Fert_quart == "Q4")
table(sw$Fert_quart)
head(sw[, c("Fertility","Fert_quart","FertAlta")])


# 2)
sw$Education_z <- as.numeric(scale(sw$Education))
sw$Examination_z <- as.numeric(scale(sw$Examination))
sw$IdxEduEx <- 0.5*sw$Education_z + 0.5*sw$Examination_z
summary(sw$IdxEduEx)


# 3)
sw$CatCat <- cut(sw$Catholic,
                 breaks = c(-Inf, 33.3, 66.6, Inf),
                 labels = c("Baja","Media","Alta"),
                 right = TRUE)
sw$MayorCat <- as.integer(sw$CatCat == "Alta")
table(sw$CatCat)
head(sw[, c("Catholic","CatCat","MayorCat")])


# 4)
norm_minmax <- function(v) (v - min(v, na.rm=TRUE)) / diff(range(v, na.rm=TRUE))
InfantMM <- norm_minmax(sw$Infant.Mortality)
FertMM   <- norm_minmax(sw$Fertility)
sw$IdxDesvInf <- 0.6*InfantMM + 0.4*FertMM
summary(sw$IdxDesvInf)
# Justificación: mayor peso a mortalidad infantil por su gravedad en políticas de salud.


# 5)
ord <- order(sw$IdxDesvInf, decreasing = TRUE)
top5 <- ord[1:5]
sw[top5, c("Fertility","Infant.Mortality","IdxDesvInf")]


# 6)
tab <- table(sw$Fert_quart, sw$CatCat)
tab
prop.table(tab, margin = 2)   # proporciones por columna (opcional)



# 7)
cortes_ed <- quantile(sw$Education, probs = c(0,.25,.5,.75,1), na.rm = TRUE)
sw$Edu_quart <- cut(sw$Education, breaks = cortes_ed, include.lowest = TRUE,
                    labels = c("Q1","Q2","Q3","Q4"), ordered_result = TRUE)
sw$EduAlta <- as.integer(sw$Edu_quart == "Q4")

tapply(sw$Fertility, sw$EduAlta, mean, na.rm = TRUE)

```
:::


