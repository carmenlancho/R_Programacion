---
title: "Tema 2 — Programación en R"
lang: es
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    self-contained: true 
execute:
  echo: true
  warning: false
  message: false
editor: source
fontsize: 11pt
---

# R

## ¿R?

**R** es un **lenguaje de programación** y un **entorno de software** diseñado específicamente para el análisis estadístico, la manipulación de datos y la visualización gráfica. Es un **software libre y de código abierto**, distribuido bajo la licencia **GNU GPL**, lo que significa que cualquiera puede usarlo, modificarlo y compartirlo sin costo.

Algunas de sus propiedades son:

-   **Multiplataforma** → Funciona en Windows, macOS y Linux.
-   **Altamente extensible** → Tiene más de **20,000 paquetes** en CRAN (repositorio oficial), además de repositorios como Bioconductor y GitHub.
-   **Especializado en estadística y ciencia de datos** → Incluye funciones nativas para análisis descriptivos, regresiones, modelos lineales y no lineales, series temporales, minería de datos, etc.
-   **Potente en visualización** → Herramientas gráficas integradas y librerías como `ggplot2`, o `plotly` permiten crear gráficos desde básicos hasta altamente interactivos.
-   **Comunidad activa** → Gran cantidad de foros, tutoriales, cursos y conferencias.

Entorno de R: <https://www.lcano.com/b/iser/_book/index.html>

**Tiene su curva de aprendizaje...¡se supera con la práctica! ;)**

**Truco**: mucho print

## Algunos ejemplos iniciales

-   Calculadora: en consola

-   Calculadora: en script. Diferencia entre .R y .qmd.

    ```{r}
    a <- 2
    b <- 3
    a*b
    ```

    ```{r}
    print('Hello world!')
    ```

```{r}
# print("Hola","casa","hogar") # error
print(c("Hola","casa","hogar")) 
```

```{r}
caracteres <- c("Hola","casa","hogar")
print(caracteres) 
```

## Variables y constantes

Una **variable** es un espacio de memoria al que se le da un nombre para almacenar un valor.

-   **Asignación:** se hace con `<-` (forma recomendada) o `=`.

-   **Dinámicas:** una variable puede cambiar de valor a lo largo de la ejecución del programa.

-   No es necesario declarar el tipo de dato (entero, float, etc.), R lo infiere automáticamente (en otros lenguajes hay que declararlo).

-   **Tipos:**

    -   Variables globales: se definen en el entorno principal (fuera de funciones) y se pueden usar en cualquier parte del script.

    -   Variables locales: se definen dentro de una función y solo existen allí. No “escapan” al entorno global.

Una **constante,** que también ocupa un espacio de memoria, es un valor fijo que no cambia durante la ejecución del programa. La diferencia entre constante y variable es que la constante es un valor predefinido, no puede cambiar (por ejemplo, $\pi$) y la variable puede cambiar su valor con la ejecución del programa.

```{r}
# Asignación de variables
x <- 10         
y <- 3          
nombre <- "Ana"  
pi_aprox <- 3.14 
```

```{r}
IVA <- 0.1
PRECIO_BASE <- 100
precio_final <- PRECIO_BASE * (1 + IVA)
precio_final

```

Dentro de una función:

```{r}
# Variables dentro de funciones no "escapan"
calcular_valor_final <- function(valor_base, impuesto) {
  valor_final <- valor_base * (1 + impuesto)
  return(valor_final)
}
```

La variable valor_final solo existe dentro de la función:

```{r}
#valor_final
# valor_final no existe fuera de la función
```

```{r}
calcular_valor_final(1000, 0.1)
```

```{r}
calcular_valor_final(5, 0.32)
```

Comentarios:

-   R distingue entre mayúsculas y minúsculas

-   R entiende igual las comillas simples (' ') y las dobles (" ").

-   A las variables y a las constantes se les debe poner un nombre identificativo.

-   Evitar todo tipo de caracteres (tildes, diéresis, ñ, etc.).

-   No pueden comenzar por caracteres ni contener espacios.

    -   Pon ejemplos válidos y no válidos de nombres de variables y constantes.

-   No se deben usar palabras reservadas de R

    ```{r}
    help(reserved)
    ```

### Ejercicios

1.  Pon ejemplos válidos y no válidos de nombres de variables y constantes.

    ```{r}
    apañarse <- 7 # sí es válido pero es mejor no utilizar tildes y caracteres específicos de un idioma
    # 7a <- 6 # no podemos empezar por un número
    # $d <- 5 # no se puede empezar con dolar
    # Num piezas <- 10 # no puede haber un espacio
    NumPiezas <- 10 # Num_piezas, num.piezas

    ```

2.  Crea tres variables: tu nombre, tu edad y tu ciudad. Muéstralas en pantalla.

3.  Declara una constante `PI = 3.1416` y calcula el área de un círculo de radio 5 (área = $\pi r^{2}$).

4.  Crea dos precios y calcula el precio final con IVA = 0.21.

5.  Usa variables `base` y `altura` para calcular el área de un triángulo (área = (base $\cdot$ altura)/2).

6.  Implementa `salario_neto(bruto, tasa = 0.15)` que retorne el neto tras impuestos.

::: {.callout-tip collapse="true"}
## **Soluciones sugeridas**

```{r}
nombre <- "Ana"; edad <- 21; ciudad <- "CDMX"
nombre; edad; ciudad

PI <- 3.1416; radio <- 5; area <- PI * radio^2; area

precio1 <- 120; precio2 <- 80; IVA <- 0.21
total <- (precio1 + precio2) * (1 + IVA); total

base <- 10; altura <- 6; (base * altura) / 2

salario_neto <- function(bruto, tasa = 0.15){ bruto * (1 - tasa)}
salario_neto(1000)
```
:::

------------------------------------------------------------------------

## Tipos de datos y objetos

R cuenta con **tipos de datos** y **estructuras de datos (u objetos)**.

**Tipos de datos principales:**

-   Datos numéricos: números reales y complejos.

    -   `numeric`: números decimales (ej. `3.14`)

    -   `integer`: enteros (ej. `5L`, la L indica “integer”)

    -   `complex`: números complejos (ej. `2+3i`)

-   Caracteres: cadenas de texto representadas entre comillas.

    -   `character`: texto o cadenas de caracteres

-   Datos lógicos: únicamente pueden tomar 2 valores: TRUE, FALSE

    -   `logical`: valores lógicos (`TRUE` / `FALSE`)

```{r}
num <- 3.14
ent <- 5L # con la L le decimos que es un entero
logi <- FALSE
txt <- "Hola"
comp <- 2 + 3i

class(num); class(ent); class(logi); class(txt); class(comp)
```

**Estructuras más comunes:**

-   **vector**: Colección ordenada de datos con una longitud determinada.

-   **matrix**: estructura bidimensional (con filas y columnas) que almacena elementos del mismo tipo de dato

-   **list**: Objeto que recoge varios tipos de elementos (componentes), que pueden ser de clases diferentes.

-   **factor**: variable categórica con niveles.

-   **data.frame**: Estructuras de datos bidimensionales, donde se recogen diferentes variables por columnas. Es una estructura tabular heterogénea.

```{r}
# Vectores (todos los elementos del mismo tipo)
v_num <- c(1, 2, 3.5)
v_chr <- c("a", "b", "c")
v_log <- c(TRUE, FALSE, TRUE)

length(v_num); class(v_num)

# Si combinamos tipos de datos, R los entenderá del mismo tipo
# Por ejemplo, en el siguiente caso entiende 1 como caracter
c(1,'beta')
```

¿Cuál es la diferencia entre el objeto matrix y el objeto data.frame?

```{r}
# Matriz: 2D del mismo tipo
m <- matrix(1:6, nrow = 2, ncol = 3)   # rellena por columnas
m

# Lista: contenedor heterogéneo
lst <- list(id = 1L, nombre = "Ana", notas = c(8.5, 9, 10))
lst$nombre; lst$notas

# Data frame: tabla (cada columna puede ser de distinto tipo)
df <- data.frame(
  id = 1:3,
  nombre = c("Ana", "Luis", "Eva"),
  nota = c(9.1, 8.3, 7.5)
)
str(df); df$nombre
```

```{r}
# Factor: categorías con niveles (útil para modelos y gráficos)
sexo <- factor(c("M", "F", "F", "M"), levels = c("F", "M"))
sexo; levels(sexo)

# Coerción (cambio de tipo) y cuidado con NAs
as.numeric("10")        # 10
as.numeric(c("10", "x"))# 10 NA (warning)
as.character(1:3)       # "1" "2" "3"

```

Profundicemos en cada una de estas estructuras.

### Vectores

Mediante el siguiente código se almacena el vector (1,2,3,4) con el nombre a:

```{r}
a <- c(1,2,3,4)
```

Para mostrarlo, se debe ejecutar a:

```{r}
a
```

Podemos crear varios vectores y combinarlos:

```{r}
v1 <- c(1,2,3)
v2 <- c(7,8,9)
v3 <- c(v1,4,5,6,v2)
v3
```

Operaciones con vectores. Se aplican elemento a elemento. Se muestra el código para 2 vectores `v1` y `v2`.

**Operaciones básicas con vectores**

| Descripción    | Código      |
|----------------|-------------|
| Concatenación  | `c(v1, v2)` |
| Suma           | `v1 + v2`   |
| Resta          | `v1 - v2`   |
| Multiplicación | `v1 * v2`   |
| División       | `v1 / v2`   |
| Potencia       | `v1 ^ v2`   |

**Funciones matemáticas**

| Descripción    | Código          |
|----------------|-----------------|
| Raíz cuadrada  | `sqrt(v1)`      |
| Valor absoluto | `abs(v1)`       |
| Exponencial    | `exp(v1)`       |
| Log. base *e*  | `log(v1)`       |
| Log. base 10   | `log10(v1)`     |
| Factorial (!)  | `factorial(v1)` |

------------------------------------------------------------------------

**Estadísticos descriptivos**

| Descripción         | Código        |
|---------------------|---------------|
| Longitud            | `length(v1)`  |
| Máximo              | `max(v1)`     |
| Mínimo              | `min(v1)`     |
| Suma                | `sum(v1)`     |
| Producto            | `prod(v1)`    |
| Media               | `mean(v1)`    |
| Mediana             | `median(v1)`  |
| Desviación estándar | `sd(v1)`      |
| Varianza            | `var(v1)`     |
| Covarianza          | `cov(v1, v2)` |
| Correlación         | `cor(v1, v2)` |

¡A practicar!

1.  Almacena 2 vectores y ejecuta las funciones previas.

2.  ¿Qué significa *Inf*? ¿Y *NaN*?

Existen 3 funciones principales para crear secuencias de números en R:

-   `seq()` (sequence)

-   `rev()` (reverse)

-   `rep()` (repeat)

```{r}
v <- c(2,7,5)
# Repeticiones
rep(v, 2)
rep(v, each = 2)
rep(v, each = 2, times = 2)
rep(v, c(2, 3, 4))

# Secuencias simples
1:10
seq(1, 10)
10:1
seq(10, 1)

# Secuencias personalizadas
seq(4, length = 8)         # 8 valores desde 4
seq(0, 40, by = 5)         # de 0 a 40 en pasos de 5
seq(0, 1, length = 4)      # 4 valores equidistantes entre 0 y 1
seq(from = 2, to = 8, by = 3)

# Revertir secuencias
rev(1:5)

# Operaciones con secuencias
2 * 1:4
```

#### Operadores lógicos

Tomarán valor TRUE o FALSE.

```{r}
a <- c(-15,4,2,10,0,-2)
a > 2
a <= -10
a > 0 & abs(a) == 2
a > 0 | abs(a) == 2
```

-   ¿Cuál es la diferencia entre = y ==?

#### Indexación

La **indexación** permite acceder a los elementos de un vector. Esto significa acceder a los valores de un vector especificando su posición dentro de corchetes `[]`. Esto se realiza indicando la posición de los elementos deseados o bien mediante el uso de operadores lógicos. Se muestra el código para un vector `v`.

| Código | Descripción |
|------------------------------------|------------------------------------|
| `v[1]` | Primer elemento |
| `v[2:4]` | Del segundo al cuarto elemento |
| `v[-(2:length(v))]` | Todos menos aquellos desde el segundo hasta el último elemento |
| `v[c(2,4,6)]` | Elementos segundo, cuarto y sexto |
| `v[v > 0]` | Elementos mayores que 0 |
| `v[v != 0]` | Elementos diferentes de 0 |
| `v[abs(v) == 3]` | Elementos con valor absoluto 3 |
| `v[v > 0 & v != 2]` | Elementos positivos **y** que no sean 2 |
| `v[v < 0 | v == 3]` | Elementos negativos **o** que sean 3 |

También existe la función `which()`. En base al siguiente código, ¿cómo crees que funciona?

```{r}
v <- c(0,3,0,1,3,0)
which(v==0)
which(v>0 & v<=2)
```

¿Y las funciones `which.min()` y `which.max()`?

#### Ejercicios

Dado el vector

```{r}
v <- -5:5
```

Indique qué se obtiene con las siguientes expresiones:

1.  `v[c(1, length(v))]`
2.  `v[3:7]`
3.  `v[-c(1, length(v))]`
4.  `v[v >= 0]`
5.  `v[abs(v) == 4]`
6.  `v[v != -3 & v != 3]`
7.  `v[v < -2 | v > 2]`

### Matrices

Una matriz $M$ de tamaño $n \times s$ es:

$M =\left( \begin{matrix} m_{11} & m_{12} & m_{13} & \cdots & m_{1s} \\ m_{21} & m_{22} & m_{23} & \cdots & m_{2s} \\ m_{31} & m_{32} & m_{33} & \cdots & m_{3s} \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ m_{n1} & m_{n2} & m_{n3} & \cdots & m_{ns} \end{matrix}\right)$

Creamos una matriz a partir de un vector:

```{r}
v <- 1:8
dim(v)<-c(4,2)
v
```

Nótese que, por defecto, R coloca los valores de arriba a abajo. Esto, por supuesto, es modificable.

```{r}
v <- 1:7
#dim(v)<-c(4,2)
#v
```

```{r}
matrix(1:8,nrow=2,ncol=4)
```

```{r}
matrix(1:3,3,3)
```

```{r}
matrix(1:3,3,3, byrow = TRUE)
```

Especificamos número de filas o de columnas:

```{r}
matrix(1:6,nrow=2)
matrix(1:4,ncol=2)
```

La función rbind() une por filas y cbind() une por columnas.

```{r}
a<-matrix(0,2,2)
b<-matrix(1,1,2)
rbind(a,b)
cbind(1,1:4)
```

#### Array

Estructura que organiza los datos en k dimensiones.

```{r}
array(1:4,c(2,2,2))
```

#### Indexación y submatrices

Al igual que accedíamos a elementos de los vectores con los \[\], podemos acceder a elementos de las matrices. Esto permite no sólo acceder a elementos, también modificarlos y obtener submatrices.

```{r}
a <- matrix(1:9*3,3,3)
a[1,2] # Elemento de la fila 1 y la columna 2
a[,3] # Tercera columna
a[2,] # Segunda fila
a[-1, -3] # Todas las filas menos la primera y todas las columnas menos la tercera
a[2:3,1] # De la fila 2 a la 3, columna 1
```

```{r}
# Cambiar elementos
a[,1]<-0
```

Algunas operaciones básicas con matrices son:

-   Dimensión de la matriz: `dim()`

-   Transpuesta: `t()`

-   Número de filas: `nrow()`

-   Número de columnas: `ncol()`

-   Suma de filas: `rowSums()`

-   Suma de columnas: `colSums()`

-   Media de las filas: `rowMeans()`

-   Media de las columnas: `colMeans()`

Investiga las funciones `is.vector()`, `is.matrix()`, `as.vector()`, `as.matrix()`. ¿Qué hacen?

#### Ejercicio

-   Crea una matriz llamada `M` de tamaño 3x3 con los números del 1 al 9.
-   Sustituye el valor de la fila 2, columna 3 por 100.
-   Muestra todos los valores de la fila 1.
-   Muestra todos los valores de la columna 2.
-   Selecciona las dos primeras filas y las dos primeras columnas.
-   Añade una nueva fila con valores `c(10,20,30)`.
-   Añade una columna con valores `c(5,5,5,5)`.
-   Añade una columna con valores `c(5,5,5,5,5)`.
-   Cambia a 0 todos los elementos mayores que 20.

### Factor

Un factor es un tipo especial de vector para representar variables de tipo atributo o categóricas. En general, la característica podrá tomar un reducido número de valores diferentes, identificados con etiquetas (*labels*) y que llamaremos **niveles** del factor (*levels*). R crea los niveles del factor a partir de los distintos valores que toma la variable (valores únicos, que se pueden obtener con la función `unique`) ordenados de forma ascendente, y almacena solamente el código de etiqueta.

```{r}
factor(c("viejo", "viejo", "nuevo1", "nuevo2"), 
       levels = c("viejo", "nuevo1", "nuevo2"))
```

Imaginemos que tenemos las siguientes piezas:

```{r}
piezas <- c(1, 2, 3, 3)
piezas
```

```{r}
piezas <- factor(piezas,labels = c("M01", "M02", "M03"))
piezas
```

#### Ejercicios

1.  Crea un vector con las categorías `"Alto"`, `"Medio"`, `"Bajo"`, repitiéndolas varias veces, y conviértelo en un factor.

    ```{r}
    niveles <- c("Alto", "Medio", "Bajo", "Alto", "Bajo")
    f <- factor(niveles)
    f
    ```

2.  Verifica los niveles del factor.

    ```{r}
    levels(f)
    ```

3.  Consulta cuántos elementos hay de cada nivel usando `table()`.

    ```{r}
    table(f)
    ```

4.  Crea un factor ordenado llamado `talla` con los valores `c("S", "M", "L", "S", "L", "M")`, donde el orden sea `S < M < L`.

    ```{r}
    talla <- factor(c("S", "M", "L", "S", "L", "M"),
                    levels = c("S", "M", "L"),
                    ordered = TRUE)
    talla

    ```

5.  Comprueba qué talla es mayor: `"S"` o `"M"`.

    ```{r}
    talla[1] < talla[2]   # TRUE
    ```

6.  Dado un vector de calificaciones `c(4, 7, 9, 5, 8, 3)`, crea un factor categorizando cada nota en:

    -   `"Suspenso"` (\<5)

    -   `"Aprobado"` (5–6.9)

    -   `"Notable"` (7–8.9)

    -   `"Sobresaliente"` (≥9)

    ```{r}
    notas <- c(4, 7, 9, 5, 8, 3)
    categorias <- cut(notas,
                      breaks = c(-Inf, 5, 7, 9, Inf),
                      labels = c("Suspenso", "Aprobado", "Notable", "Sobresaliente"),
                      right = FALSE)
    categorias
    table(categorias)

    ```

### Listas

Las listas son estructuras de datos que contienen una colección de elementos indexados, que pueden además tener un nombre. Pueden ser heterogéneas en el sentido de que cada elemento de la lista puede ser de cualquier tipo.

Las listas se pueden anidar, de forma que un elemento de la lista puede ser, a su vez, una lista. Accederemos a estos elementos profundizando con el mismo operador `$`, por ejemplo `lista1$elemento1$subelemento2`.

```{r}
# Lista: contenedor heterogéneo
lst <- list(fruta = "manzana", peso = c(125, 115, 209))
lst; lst$fruta; lst$peso
```

```{r}
lst["fruta"]; lst['peso'] 
```

```{r}
lst[1]; lst[[1]]
```

#### Ejercicios

1.  Crear una lista llamada `persona` con los siguientes elementos:

    -   nombre: `"Carmen"`

    -   edad: `21`

    -   notas: `c(8.5, 9, 7.5)`

    ```{r}
    persona <- list(
      nombre = "Carmen",
      edad = 21,
      notas = c(8.5, 9, 7.5)
    )

    ```

2.  Accede al nombre de la persona usando `$` y usando `[[]]`

    ```{r}
    persona$nombre
    persona[["nombre"]]
    ```

3.  A partir de la lista `persona`, accede a la segunda nota.

    ```{r}
    persona$notas[2]
    ```

4.  Cambia la edad de `persona` a `24`.

    ```{r}
    persona$edad <- 24
    ```

5.  Agrega un nuevo elemento llamado `deporte` con valor `"Atletismo"`.

    ```{r}
    persona$deporte <- "Atletismo"
    ```

6.  Crea una lista `clase` con tres alumnos, cada uno con sus propios datos (nombre, edad y notas).

    ```{r}
    clase <- list(
      alumno1 = list(nombre = "Ana", edad = 21, notas = c(9, 8, 7)),
      alumno2 = list(nombre = "Luis", edad = 22, notas = c(6, 7, 8)),
      alumno3 = list(nombre = "Carlos", edad = 23, notas = c(10, 9, 9.5))
    )
    ```

7.  Accede al nombre del segundo alumno.

    ```{r}
    clase$alumno2$nombre
    ```

8.  Resta un punto a la primera nota del alumno 3.

    ```{r}
    clase$alumno3$notas[1] <- clase$alumno3$notas[1] - 1
    ```
