---
title: "Tema 2 — Programación en R"
lang: es
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    self-contained: true 
execute:
  echo: true
  warning: false
  message: false
editor: source
fontsize: 11pt
---



# Funciones

Una función es un bloque de código reutilizable que realiza una tarea específica. Nos permite organizar el código y evitar repeticiones. Pueden tener:

  * Inputs: argumentos de entrada.
  * Outputs: argumentos de salida.

En R podemos encontrar principalmente dos tipos de funciones. Las predefinicas que ya vienen en el propio R y que hemos estado usando como por ejemplo `mean()`, `sum()`, `print()`, etc. También existen las funciones definidas por el usuario mediante la sentencia `function()`. Justo en estas últimas son en las que nos vamos a centrar en esta sección.

Sintaxis:
```r
nombre_funcion <- function(argumento1, argumento2, ...) {
  # instrucciones
  # ...
  return(resultado)
}
```

  * nombre_funcion: será el nombre que le pongamos a la función. Al igual que los nombres que le ponemos a las variables, no puede contener espacios ni comenzar por caracteres especiales.
  * argumento1, argumento2,... : son los inputs que recibe a la función. También los definimos nosotros.
  * return(resultado): valor (u objeto) que devuelve la función. Si no se pone `return()` devuelve el último valor calculado.
  
  
¿Qué ventaja tiene usar funciones?

* Reutilización: Escribes el código una vez y lo usas las veces que quieras.
* Claridad: Nombrar una función hace que el código sea más legible.
* Modularidad: Separa el programa en partes lógicas.
* Mantenimiento: Si hay que cambiar algo, solo modificas la función.

## Ejemplos
#### Función sin argumentos
```{r}
hola <- function() {
  print("¡Hola mundo!")
}
hola()
```

#### Función con un argumento
```{r}
cuadrado <- function(x) {
  return(x^2)
}
cuadrado(4)  # devuelve 16
```

#### Función con varios argumentos
```{r}
suma <- function(a, b) {
  a + b  # también vale sin return, devuelve el último valor
}
suma(3, 5)
```

¡Ojo! Los argumentos se deben meter en el orden correcto.


### Función con valores por defecto
```{r}
saludo <- function(nombre = "Estudiante") {
  paste("Hola", nombre)
}
saludo()           # "Hola Estudiante"
saludo("María")    # "Hola María"

```

### Función que usa condicionales
```{r}
clasificar_nota <- function(nota) {
  if (nota < 5) {
    return("Suspenso")
  } else if (nota < 7) {
    return("Aprobado")
  } else if (nota < 9) {
    return("Notable")
  } else {
    return("Sobresaliente")
  }
}
clasificar_nota(8)

```


Algunas observaciones sobre las funciones:

  * Las variables definidas dentro de la función son locales y no afectan a las de fuera.
  * Parámetros por defecto: si no pasas ese argumento, toma ese valor.
  * Si llamas a los inputs por posición, debes respetar el orden declarado en la función.
  
  

::: {.callout-note}
##  Ejercicios

1. Crea una función `saludar()` que muestre "Hola a todos".

2. Crea una función `doble(x)` que devuelva el doble de x.

3. Crea una función `sumar3(a, b, c)` que devuelva la suma de tres números.

4. Crea una función `par_impar(n)` que diga "Par" o "Impar".

5. Crea una función `mayor(a, b)` que devuelva el mayor de dos números.

6. Crea una función `es_positivo(x)` que devuelva TRUE o FALSE en función de si es positivo o no.

7. Crea una función `positivos(v)` que reciba un vector y devuelva solo los números positivos.

8. Crea una función `clasificar_numeros(v)` que devuelva "Positivo", "Negativo" o "Cero" para cada elemento de `v` (usa `ifelse()`).

9. Crea una función `fibonacci(n)` que devuelva un vector con los n primeros términos de la serie de Fibonacci.

10. Crea una función para el juego de piedra, papel o tijera que hemos ido programando a lo largo del Tema 2. ¿Qué input le pondrías?

:::

::: {.callout-tip collapse="true"}
## Soluciones

```{r}

# 1) saludar()
saludar <- function() {
  print("Hola a todos")
}
# saludar()

# 2) doble(x)
doble <- function(x) {
  valor_final <- 2 * x
  return(valor_final)
}
# doble(4)

# 3) sumar3(a, b, c)
sumar3 <- function(a, b, c) {
  suma <- a + b + c
  return(suma)
}
# sumar3(1, 2, 3)

# 4) par_impar(n)
par_impar <- function(n) {
  if (n %% 2 == 0) {"Par"} else {"Impar"}
}
# par_impar(7)

# 5) mayor(a, b)
mayor <- function(a, b) {
  if (a >= b){
    a 
  } else {
    b
  }
}
# mayor(3, 5)

# 6) es_positivo(x)
es_positivo <- function(x) {
  comparacion <- x > 0
  return(comparacion)
}
# es_positivo(c(-2, 0, 3))

# 7) positivos(v)  -> devuelve solo los > 0
positivos <- function(v) {
  pos <- v[v > 0]
  return(pos)
}
# positivos(c(-2, 3, 0, 5, -1))

# 8) clasificar_numeros(v) -> "Positivo", "Negativo", "Cero"
clasificar_numeros <- function(v) {
  ifelse(v > 0, "Positivo", ifelse(v < 0, "Negativo", "Cero"))
}
# clasificar_numeros(c(-2, 0, 7))

# 9) fibonacci(n) -> primeros n términos (comenzando 0, 1, 1, 2, ...)
fibonacci <- function(n) {
  
  if (n<=0){
    fib <- c('n debe ser un número entero mayor que 0')
  } else if (n==1){
    fib <- 0
  } else if (n==2){
    fib <- c(0,1)
  } else{
    fib <- numeric(n)
    fib[1] <- 0
    fib[2] <- 1
    for (i in 3:n) {
      fib[i] <- fib[i - 1] + fib[i - 2]
    }
  }
  
return(fib)
}
# fibonacci(10)




```
:::




